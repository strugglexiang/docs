# 概念
代理模式：当客户端不方便直接访问一个对象时，可以提供一个代理对象做为中介，这个代理对象能够直接访问目标对象。

代理模式在`js`中还是很常见的，给我留下最深印象的一般是**ajax跨域时使用到的反向代理**。


# 构成
代理模式一般有两部分组成：
1. 真实对象：客户端需要访问的真实对象。
2. 代理对象：能够对真实对象访问的代理对象。


# 使用场景
代理模式一般有2个使用场景：
1. 不能直接访问目标对象，需要通过代理中介。
2. 可以充当一层拦截，使得外界对该对象的访问，都必须先通过这层拦截。因为这个拦截机制，可以对外界访问进行改写和过滤。


# 示例1
Tom喜欢上了一个女孩Mary，想给她送花
```js
const Tom = {
    sendFlowers(target) {
        target.receiveFlowers()
    }
}

const Mary = {
    receiveFlowers() {
        console.log('Mary收到花')
    }
}

Tom.sendFlowers(Mary)
```

但是Tom不是十分了解Mary，他想委托另一个了解Mary的人Bob， 让Bob在Marry心情好的时候代表他赠送。
```js
const Tom = {
    sendFlowers(target) {
        target.receiveFlowers()
    }
}

const Mary = {
    receiveFlowers() {
        console.log('Mary收到花')
    }
}


const Bob = {
    sendFlowers(sender, receiver) {
        sender.sendFlowers(receiver)
    }
}

Bob.sendFlowers(Tom, Mary)
```
在这个过程中，Bob就是一个代理对象。


# 示例2
图片懒加载：为使图片在请求过程中不造成页面空白。在请求时，显示预留的`loading图片`，请求成功后，再显示请求的图片。
```js
const lazyLoad = (function() {
    const realImg = document.createElement('img')
    //-----
    const loadImg = new Image()
    loadImg.onload = function() {
        realImg.src = this.src
    }
    //-----
    document.body.appendChild(realImg)

    return {
        setSrc(src) {
            realImg.src = '../../assert/loading.gif'
            loadImg.src = src
        }
    }
})()
lazyLoad.setSrc('https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2329667634,3759844774&fm=26&gp=0.jpg') 
```
上述代码，lazyLoad对象有两个职责：
1. 设置懒加载的src。
2. 设置真实的src。

两个功能是耦合在一起的，不符合单一职责原则。下面用代理模式将职责分离，实现图片加载的功能扩展。
```js
//---- 真实对象
const imgLoad = (function() {
    let img = document.createElement('img')
    document.body.appendChild(img)
    return {
        setSrc(src) {
            img.src = src
        }
    }
})()

//----- 代理对象
const lazyLoad = (function() {
    let img = new Image
    img.onload = function() {
        imgLoad.setSrc(this.src)
    }
    return {
        setSrc(src) {
            imgLoad.setSrc('../../assert/loading.gif')
            img.src = src
        }
    }
})()

lazyLoad.setSrc('https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2329667634,3759844774&fm=26&gp=0.jpg')
```

# es6的新特性Proxy
es6增加了新的特性Proxy。在访问到目标对象之前，必须先通过一层拦截。`Proxy`实例**代理**了某些**操作**。

es6支持的拦截操作共有13钟，下面是这十三种拦截方式的简单学习示例。

::: tip 提示
以下代码不做解释，仅作为作者的练习：      
请参考：阮一峰的[ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/proxy)
:::


* * *
**get**      
对某个属性取值的拦截。依次接收3个参数：目标对象、属性名、Proxy对象本身(严格上，操作行为所针对的对象)

基础使用：
```js
const proxy1 = new Proxy({}, {
    get(target, property, receiver) {
        if(property === 'foo') {
            return 'foo'
        }
        return target[property]
    }
})

console.log(proxy1.foo) // foo
console.log(proxy1.a) // undefined
```

函数链式调用:
```js
const chainProxy = (function() {
    return function(value) {
        const chain = []
        const handler = {
            get(target, property, receiver) {
                if(property === 'get') {
                    return chain.reduce((value, fn) => {
                        return fn(value)
                    }, value)
                }         
                chain.push(window[property])   
                return receiver
            }
        }
        return new Proxy({}, handler)
    }
}())

function double(value) {
    return value * 2
}

function pow(value) {
    return value * value
}  

function reverse(value) {
    return value.toString().split('').reverse().join('') || 0
}

let result = chainProxy(5).pow.double.reverse.get 
console.log(result)//5*5*2后颠倒  结果05
```

数组负索引：
```js
const arrayProxy = (function() {
    return function(array = []) {
        return new Proxy(array, {
            get(target, property, receiver) {
                let index = Number(property)
                if(index < 0) {
                    return target[index +  target.length]
                }
                return target[index]
            }
        })
    }
}())

const a = arrayProxy([1, 2, 3])
console.log(a[-1]) //3
console.log(a[-2]) //2
console.log(a[-3]) //1
```

* * *

